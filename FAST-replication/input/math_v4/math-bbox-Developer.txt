public void testContains() { Line l = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Assert.assertTrue(l.contains(new Vector2D(0, 1))); Assert.assertTrue(l.contains(new Vector2D(1, 2))); Assert.assertTrue(l.contains(new Vector2D(7, 8))); Assert.assertTrue(! l.contains(new Vector2D(8, 7))); }
public void testSimilar() throws MathIllegalArgumentException, MathArithmeticException { Vector3D p1 = new Vector3D (1.2, 3.4, -5.8); Vector3D p2 = new Vector3D (3.4, -5.8, 1.2); Line   lA = new Line(p1, p2); Line   lB = new Line(p2, p1); Assert.assertTrue(lA.isSimilarTo(lB)); Assert.assertTrue(! lA.isSimilarTo(new Line(p1, p1.add(lA.getDirection().orthogonal())))); }
public void testPointDistance() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10); Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10); }
public void testLineDistance() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(1.0, l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))), 1.0e-10); Assert.assertEquals(0.5, l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))), 1.0e-10); Assert.assertEquals(0.0, l.distance(l), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))), 1.0e-10); Assert.assertEquals(FastMath.sqrt(8), l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))), 1.0e-10); }
public void testClosest() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.5, l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))).distance(new Vector3D(-0.5, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(l).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))).distance(new Vector3D(0, -2, -2)), 1.0e-10); }
public void testIntersection() { Line  l1 = new Line(new Vector2D( 0, 1), new Vector2D(1, 2)); Line  l2 = new Line(new Vector2D(-1, 2), new Vector2D(2, 1)); Vector2D p = l1.intersection(l2); Assert.assertEquals(0.5, p.getX(), 1.0e-10); Assert.assertEquals(1.5, p.getY(), 1.0e-10); }
public void testRevert() { // setup Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000), new Vector3D(1650757.5050732433, 6160710.879908984, 0.9)); Vector3D expected = line.getDirection().negate(); // action Line reverted = line.revert(); // verify Assert.assertArrayEquals(expected.toArray(), reverted.getDirection().toArray(), 0); }
public void testEndPoints() { Vector2D p1 = new Vector2D(-1, -7); Vector2D p2 = new Vector2D(7, -1); Segment segment = new Segment(p1, p2, new Line(p1, p2)); SubLine sub = new SubLine(segment); List<Segment> segments = sub.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertEquals(0.0, new Vector2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10); }
public void testNoEndPoints() { SubLine wholeLine = new Line(new Vector2D(-1, 7), new Vector2D(7, 1)).wholeHyperplane(); List<Segment> segments = wholeLine.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() < 0); }
public void testNoSegments() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet())); List<Segment> segments = empty.getSegments(); Assert.assertEquals(0, segments.size()); }
public void testSeveralSegments() { SubLine twoSubs = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2), new IntervalsSet(3, 4))); List<Segment> segments = twoSubs.getSegments(); Assert.assertEquals(2, segments.size()); }
public void testHalfInfiniteNeg() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() < 0); Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10); }
public void testHalfInfinitePos() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new IntervalsSet(0.0, Double.POSITIVE_INFINITY)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() > 0); }
public void testIntersectionInsideInside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 2)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12); }
public void testIntersectionInsideBoundary() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testIntersectionInsideOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testIntersectionBoundaryBoundary() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testIntersectionBoundaryOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testIntersectionOutsideOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(1.5, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testIntersectionNotIntersecting() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); }
public void testAbscissa() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(0.0, (l.toSubSpace(new Vector2D(-3, 4))).getX(), 1.0e-10); Assert.assertEquals(0.0, (l.toSubSpace(new Vector2D( 3, -4))).getX(), 1.0e-10); Assert.assertEquals(-5.0, (l.toSubSpace(new Vector2D( 7, -1))).getX(), 1.0e-10); Assert.assertEquals( 5.0, (l.toSubSpace(new Vector2D(-1, -7))).getX(), 1.0e-10); }
public void testOffset() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(-5.0, l.getOffset(new Vector2D(5, -3)), 1.0e-10); Assert.assertEquals(+5.0, l.getOffset(new Vector2D(-5, 2)), 1.0e-10); }
public void testDistance() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(+5.0, l.distance(new Vector2D(5, -3)), 1.0e-10); Assert.assertEquals(+5.0, l.distance(new Vector2D(-5, 2)), 1.0e-10); }
public void testPointAt() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); for (double a = -2.0; a < 2.0; a += 0.2) { Vector1D pA = new Vector1D(a); Vector2D point = l.toSpace(pA); Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10); Assert.assertEquals(0.0, l.getOffset(point),  1.0e-10); for (double o = -2.0; o < 2.0; o += 0.2) { point = l.getPointAt(pA, o); Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10); Assert.assertEquals(o, l.getOffset(point),  1.0e-10); } } }
public void testOriginOffset() { Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10); Line l2 = new Line(new Vector2D(1, 2), new Vector2D(0, 1)); Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10); }
public void testParallel() { Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Line l2 = new Line(new Vector2D(2, 2), new Vector2D(3, 3)); Assert.assertTrue(l1.isParallelTo(l2)); Line l3 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.5)); Assert.assertTrue(l1.isParallelTo(l3)); Line l4 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.51)); Assert.assertTrue(! l1.isParallelTo(l4)); }
public void testTransform() throws MathIllegalArgumentException { Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0)); Transform<Euclidean2D, Euclidean1D> t1 = Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5)); Assert.assertEquals(0.5 * FastMath.PI, ((Line) t1.apply(l1)).getAngle(), 1.0e-10); Line l2 = new Line(new Vector2D(0.0, 0.0), new Vector2D(1.0, 1.0)); Transform<Euclidean2D, Euclidean1D> t2 = Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5)); Assert.assertEquals(FastMath.atan2(1.0, -2.0), ((Line) t2.apply(l2)).getAngle(), 1.0e-10); }
public void testIntersectionParallel() { final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2)); final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); }
