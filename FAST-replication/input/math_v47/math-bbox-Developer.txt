public void testConstructor() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(3.0, z.getReal(), 1.0e-5); Assert.assertEquals(4.0, z.getImaginary(), 1.0e-5); }
public void testConstructorNaN() { Complex z = new Complex(3.0, Double.NaN); Assert.assertTrue(z.isNaN()); z = new Complex(nan, 4.0); Assert.assertTrue(z.isNaN()); z = new Complex(3.0, 4.0); Assert.assertFalse(z.isNaN()); }
public void testAbs() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(5.0, z.abs(), 1.0e-5); }
public void testAbsNaN() { Assert.assertTrue(Double.isNaN(Complex.NaN.abs())); Complex z = new Complex(inf, nan); Assert.assertTrue(Double.isNaN(z.abs())); }
public void testAbsInfinite() { Complex z = new Complex(inf, 0); Assert.assertEquals(inf, z.abs(), 0); z = new Complex(0, neginf); Assert.assertEquals(inf, z.abs(), 0); z = new Complex(inf, neginf); Assert.assertEquals(inf, z.abs(), 0); }
public void testAdd() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.add(y); Assert.assertEquals(8.0, z.getReal(), 1.0e-5); Assert.assertEquals(10.0, z.getImaginary(), 1.0e-5); }
public void testAddNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.add(Complex.NaN); Assert.assertSame(Complex.NaN, z); z = new Complex(1, nan); Complex w = x.add(z); Assert.assertSame(Complex.NaN, w); }
public void testAddInf() { Complex x = new Complex(1, 1); Complex z = new Complex(inf, 0); Complex w = x.add(z); Assert.assertEquals(w.getImaginary(), 1, 0); Assert.assertEquals(inf, w.getReal(), 0); x = new Complex(neginf, 0); Assert.assertTrue(Double.isNaN(x.add(z).getReal())); }
public void testScalarAdd() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); }
public void testScalarAddNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); }
public void testScalarAddInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); x = new Complex(neginf, 0); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); }
public void testConjugate() { Complex x = new Complex(3.0, 4.0); Complex z = x.conjugate(); Assert.assertEquals(3.0, z.getReal(), 1.0e-5); Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5); }
public void testConjugateNaN() { Complex z = Complex.NaN.conjugate(); Assert.assertTrue(z.isNaN()); }
public void testConjugateInfiinite() { Complex z = new Complex(0, inf); Assert.assertEquals(neginf, z.conjugate().getImaginary(), 0); z = new Complex(0, neginf); Assert.assertEquals(inf, z.conjugate().getImaginary(), 0); }
public void testDivide() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.divide(y); Assert.assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5); Assert.assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5); }
public void testDivideReal() { Complex x = new Complex(2d, 3d); Complex y = new Complex(2d, 0d); Assert.assertEquals(new Complex(1d, 1.5), x.divide(y)); }
public void testDivideImaginary() { Complex x = new Complex(2d, 3d); Complex y = new Complex(0d, 2d); Assert.assertEquals(new Complex(1.5d, -1d), x.divide(y)); }
public void testDivideInf() { Complex x = new Complex(3, 4); Complex w = new Complex(neginf, inf); Assert.assertTrue(x.divide(w).equals(Complex.ZERO)); Complex z = w.divide(x); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertEquals(inf, z.getImaginary(), 0); w = new Complex(inf, inf); z = w.divide(x); Assert.assertTrue(Double.isNaN(z.getImaginary())); Assert.assertEquals(inf, z.getReal(), 0); w = new Complex(1, inf); z = w.divide(w); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); }
public void testDivideZero() { Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.ZERO); Assert.assertEquals(z, Complex.INF); }
public void testDivideZeroZero() { Complex x = new Complex(0.0, 0.0); Complex z = x.divide(Complex.ZERO); Assert.assertEquals(z, Complex.NaN); }
public void testDivideNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.NaN); Assert.assertTrue(z.isNaN()); }
public void testDivideNaNInf() { Complex z = oneInf.divide(Complex.ONE); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertEquals(inf, z.getImaginary(), 0); z = negInfNegInf.divide(oneNaN); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); z = negInfInf.divide(Complex.ONE); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); }
public void testScalarDivide() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.divide(yComplex), x.divide(yDouble)); }
public void testScalarDivideNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.divide(yComplex), x.divide(yDouble)); }
public void testScalarDivideInf() { Complex x = new Complex(1,1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); yDouble = Double.NEGATIVE_INFINITY; yComplex = new Complex(yDouble); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); x = new Complex(1, Double.NEGATIVE_INFINITY); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); }
public void testScalarDivideZero() { Complex x = new Complex(1,1); TestUtils.assertEquals(x.divide(Complex.ZERO), x.divide(0), 0); }
public void testMultiply() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.multiply(y); Assert.assertEquals(-9.0, z.getReal(), 1.0e-5); Assert.assertEquals(38.0, z.getImaginary(), 1.0e-5); }
public void testMultiplyNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.multiply(Complex.NaN); Assert.assertSame(Complex.NaN, z); }
public void testMultiplyNaNInf() { Complex z = new Complex(1,1); Complex w = z.multiply(infOne); Assert.assertEquals(w.getReal(), inf, 0); Assert.assertEquals(w.getImaginary(), inf, 0); // [MATH-164] Assert.assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF)); Assert.assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF)); Assert.assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF)); w = oneInf.multiply(oneNegInf); Assert.assertEquals(w.getReal(), inf, 0); Assert.assertEquals(w.getImaginary(), inf, 0); w = negInfNegInf.multiply(oneNaN); Assert.assertTrue(Double.isNaN(w.getReal())); Assert.assertTrue(Double.isNaN(w.getImaginary())); z = new Complex(1, neginf); Assert.assertSame(Complex.INF, z.multiply(z)); }
public void testScalarMultiply() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); }
public void testScalarMultiplyNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); }
public void testScalarMultiplyInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); yDouble = Double.NEGATIVE_INFINITY; yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); }
public void testNegate() { Complex x = new Complex(3.0, 4.0); Complex z = x.negate(); Assert.assertEquals(-3.0, z.getReal(), 1.0e-5); Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5); }
public void testNegateNaN() { Complex z = Complex.NaN.negate(); Assert.assertTrue(z.isNaN()); }
public void testSubtract() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.subtract(y); Assert.assertEquals(-2.0, z.getReal(), 1.0e-5); Assert.assertEquals(-2.0, z.getImaginary(), 1.0e-5); }
public void testSubtractNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.subtract(Complex.NaN); Assert.assertSame(Complex.NaN, z); z = new Complex(1, nan); Complex w = x.subtract(z); Assert.assertSame(Complex.NaN, w); }
public void testSubtractInf() { Complex x = new Complex(1, 1); Complex z = new Complex(neginf, 0); Complex w = x.subtract(z); Assert.assertEquals(w.getImaginary(), 1, 0); Assert.assertEquals(inf, w.getReal(), 0); x = new Complex(neginf, 0); Assert.assertTrue(Double.isNaN(x.subtract(z).getReal())); }
public void testScalarSubtract() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); }
public void testScalarSubtractNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); }
public void testScalarSubtractInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); x = new Complex(neginf, 0); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); }
public void testEqualsNull() { Complex x = new Complex(3.0, 4.0); Assert.assertFalse(x.equals(null)); }
public void testEqualsClass() { Complex x = new Complex(3.0, 4.0); Assert.assertFalse(x.equals(this)); }
public void testEqualsSame() { Complex x = new Complex(3.0, 4.0); Assert.assertTrue(x.equals(x)); }
public void testEqualsTrue() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(3.0, 4.0); Assert.assertTrue(x.equals(y)); }
public void testEqualsRealDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0); Assert.assertFalse(x.equals(y)); }
public void testEqualsImaginaryDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); Assert.assertFalse(x.equals(y)); }
public void testEqualsNaN() { Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); Complex complexNaN = Complex.NaN; Assert.assertTrue(realNaN.equals(imaginaryNaN)); Assert.assertTrue(imaginaryNaN.equals(complexNaN)); Assert.assertTrue(realNaN.equals(complexNaN)); }
public void testHashCode() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); Assert.assertFalse(x.hashCode()==y.hashCode()); y = new Complex(0.0 + Double.MIN_VALUE, 0.0); Assert.assertFalse(x.hashCode()==y.hashCode()); Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode()); Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode()); }
public void testAcos() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.936812, -2.30551); TestUtils.assertEquals(expected, z.acos(), 1.0e-5); TestUtils.assertEquals(new Complex(FastMath.acos(0), 0), Complex.ZERO.acos(), 1.0e-12); }
public void testAcosInf() { TestUtils.assertSame(Complex.NaN, oneInf.acos()); TestUtils.assertSame(Complex.NaN, oneNegInf.acos()); TestUtils.assertSame(Complex.NaN, infOne.acos()); TestUtils.assertSame(Complex.NaN, negInfOne.acos()); TestUtils.assertSame(Complex.NaN, infInf.acos()); TestUtils.assertSame(Complex.NaN, infNegInf.acos()); TestUtils.assertSame(Complex.NaN, negInfInf.acos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.acos()); }
public void testAcosNaN() { Assert.assertTrue(Complex.NaN.acos().isNaN()); }
public void testAsin() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.633984, 2.30551); TestUtils.assertEquals(expected, z.asin(), 1.0e-5); }
public void testAsinNaN() { Assert.assertTrue(Complex.NaN.asin().isNaN()); }
public void testAsinInf() { TestUtils.assertSame(Complex.NaN, oneInf.asin()); TestUtils.assertSame(Complex.NaN, oneNegInf.asin()); TestUtils.assertSame(Complex.NaN, infOne.asin()); TestUtils.assertSame(Complex.NaN, negInfOne.asin()); TestUtils.assertSame(Complex.NaN, infInf.asin()); TestUtils.assertSame(Complex.NaN, infNegInf.asin()); TestUtils.assertSame(Complex.NaN, negInfInf.asin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.asin()); }
public void testAtan() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.44831, 0.158997); TestUtils.assertEquals(expected, z.atan(), 1.0e-5); }
public void testAtanInf() { TestUtils.assertSame(Complex.NaN, oneInf.atan()); TestUtils.assertSame(Complex.NaN, oneNegInf.atan()); TestUtils.assertSame(Complex.NaN, infOne.atan()); TestUtils.assertSame(Complex.NaN, negInfOne.atan()); TestUtils.assertSame(Complex.NaN, infInf.atan()); TestUtils.assertSame(Complex.NaN, infNegInf.atan()); TestUtils.assertSame(Complex.NaN, negInfInf.atan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.atan()); }
public void testAtanI() { for (int i = -10; i < 10; i++) { System.out.println(new Complex(0, 1 - 0.1 * i).atan()); } Assert.assertTrue(Complex.I.atan().isInfinite()); }
public void testAtanNaN() { Assert.assertTrue(Complex.NaN.atan().isNaN()); }
public void testCos() { Complex z = new Complex(3, 4); Complex expected = new Complex(-27.03495, -3.851153); TestUtils.assertEquals(expected, z.cos(), 1.0e-5); }
public void testCosNaN() { Assert.assertTrue(Complex.NaN.cos().isNaN()); }
public void testCosInf() { TestUtils.assertSame(infNegInf, oneInf.cos()); TestUtils.assertSame(infInf, oneNegInf.cos()); TestUtils.assertSame(Complex.NaN, infOne.cos()); TestUtils.assertSame(Complex.NaN, negInfOne.cos()); TestUtils.assertSame(Complex.NaN, infInf.cos()); TestUtils.assertSame(Complex.NaN, infNegInf.cos()); TestUtils.assertSame(Complex.NaN, negInfInf.cos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cos()); }
public void testCosh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.58066, -7.58155); TestUtils.assertEquals(expected, z.cosh(), 1.0e-5); }
public void testCoshNaN() { Assert.assertTrue(Complex.NaN.cosh().isNaN()); }
public void testCoshInf() { TestUtils.assertSame(Complex.NaN, oneInf.cosh()); TestUtils.assertSame(Complex.NaN, oneNegInf.cosh()); TestUtils.assertSame(infInf, infOne.cosh()); TestUtils.assertSame(infNegInf, negInfOne.cosh()); TestUtils.assertSame(Complex.NaN, infInf.cosh()); TestUtils.assertSame(Complex.NaN, infNegInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh()); }
public void testExp() { Complex z = new Complex(3, 4); Complex expected = new Complex(-13.12878, -15.20078); TestUtils.assertEquals(expected, z.exp(), 1.0e-5); TestUtils.assertEquals(Complex.ONE, Complex.ZERO.exp(), 10e-12); Complex iPi = Complex.I.multiply(new Complex(pi,0)); TestUtils.assertEquals(Complex.ONE.negate(), iPi.exp(), 10e-12); }
public void testExpNaN() { Assert.assertTrue(Complex.NaN.exp().isNaN()); }
public void testExpInf() { TestUtils.assertSame(Complex.NaN, oneInf.exp()); TestUtils.assertSame(Complex.NaN, oneNegInf.exp()); TestUtils.assertSame(infInf, infOne.exp()); TestUtils.assertSame(Complex.ZERO, negInfOne.exp()); TestUtils.assertSame(Complex.NaN, infInf.exp()); TestUtils.assertSame(Complex.NaN, infNegInf.exp()); TestUtils.assertSame(Complex.NaN, negInfInf.exp()); TestUtils.assertSame(Complex.NaN, negInfNegInf.exp()); }
public void testLog() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.60944, 0.927295); TestUtils.assertEquals(expected, z.log(), 1.0e-5); }
public void testLogNaN() { Assert.assertTrue(Complex.NaN.log().isNaN()); }
public void testLogInf() { TestUtils.assertEquals(new Complex(inf, pi / 2), oneInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 2), oneNegInf.log(), 10e-12); TestUtils.assertEquals(infZero, infOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi), negInfOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi / 4), infInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 4), infNegInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, 3d * pi / 4), negInfInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4), negInfNegInf.log(), 10e-12); }
public void testLogZero() { TestUtils.assertSame(negInfZero, Complex.ZERO.log()); }
public void testPow() { Complex x = new Complex(3, 4); Complex y = new Complex(5, 6); Complex expected = new Complex(-1.860893, 11.83677); TestUtils.assertEquals(expected, x.pow(y), 1.0e-5); }
public void testPowNaNBase() { Complex x = new Complex(3, 4); Assert.assertTrue(Complex.NaN.pow(x).isNaN()); }
public void testPowNaNExponent() { Complex x = new Complex(3, 4); Assert.assertTrue(x.pow(Complex.NaN).isNaN()); }
public void testPowInf() { TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf)); }
public void testPowZero() { TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ZERO)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.I)); TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, Complex.I.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(Complex.ZERO), 10e-12); }
public void testScalarPow() { Complex x = new Complex(3, 4); double yDouble = 5.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); }
public void testScalarPowNaNBase() { Complex x = Complex.NaN; double yDouble = 5.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); }
public void testScalarPowNaNExponent() { Complex x = new Complex(3, 4); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); }
public void testScalarPowInf() { TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infOne.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfOne.pow(1.0)); TestUtils.assertSame(Complex.NaN,infInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfInf.pow(10)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infInf.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.POSITIVE_INFINITY)); }
public void testScalarPowZero() { TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(1.0)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(0.0)); TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(0.0), 10e-12); TestUtils.assertEquals(Complex.ONE, Complex.I.pow(0.0), 10e-12); TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(0.0), 10e-12); }
public void testpowNull() { Complex.ONE.pow(null); }
public void testSin() { Complex z = new Complex(3, 4); Complex expected = new Complex(3.853738, -27.01681); TestUtils.assertEquals(expected, z.sin(), 1.0e-5); }
public void testSinInf() { TestUtils.assertSame(infInf, oneInf.sin()); TestUtils.assertSame(infNegInf, oneNegInf.sin()); TestUtils.assertSame(Complex.NaN, infOne.sin()); TestUtils.assertSame(Complex.NaN, negInfOne.sin()); TestUtils.assertSame(Complex.NaN, infInf.sin()); TestUtils.assertSame(Complex.NaN, infNegInf.sin()); TestUtils.assertSame(Complex.NaN, negInfInf.sin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sin()); }
public void testSinNaN() { Assert.assertTrue(Complex.NaN.sin().isNaN()); }
public void testSinh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.54812, -7.61923); TestUtils.assertEquals(expected, z.sinh(), 1.0e-5); }
public void testSinhNaN() { Assert.assertTrue(Complex.NaN.sinh().isNaN()); }
public void testSinhInf() { TestUtils.assertSame(Complex.NaN, oneInf.sinh()); TestUtils.assertSame(Complex.NaN, oneNegInf.sinh()); TestUtils.assertSame(infInf, infOne.sinh()); TestUtils.assertSame(negInfInf, negInfOne.sinh()); TestUtils.assertSame(Complex.NaN, infInf.sinh()); TestUtils.assertSame(Complex.NaN, infNegInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh()); }
public void testSqrtRealPositive() { Complex z = new Complex(3, 4); Complex expected = new Complex(2, 1); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); }
public void testSqrtRealZero() { Complex z = new Complex(0.0, 4); Complex expected = new Complex(1.41421, 1.41421); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); }
public void testSqrtRealNegative() { Complex z = new Complex(-3.0, 4); Complex expected = new Complex(1, 2); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); }
public void testSqrtImaginaryZero() { Complex z = new Complex(-3.0, 0.0); Complex expected = new Complex(0.0, 1.73205); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); }
public void testSqrtImaginaryNegative() { Complex z = new Complex(-3.0, -4.0); Complex expected = new Complex(1.0, -2.0); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); }
public void testSqrtPolar() { double r = 1; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 11; j++) { theta += pi /12; Complex z = ComplexUtils.polar2Complex(r, theta); Complex sqrtz = ComplexUtils.polar2Complex(FastMath.sqrt(r), theta / 2); TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12); } } }
public void testSqrtNaN() { Assert.assertTrue(Complex.NaN.sqrt().isNaN()); }
public void testSqrtInf() { TestUtils.assertSame(infNaN, oneInf.sqrt()); TestUtils.assertSame(infNaN, oneNegInf.sqrt()); TestUtils.assertSame(infZero, infOne.sqrt()); TestUtils.assertSame(zeroInf, negInfOne.sqrt()); TestUtils.assertSame(infNaN, infInf.sqrt()); TestUtils.assertSame(infNaN, infNegInf.sqrt()); TestUtils.assertSame(nanInf, negInfInf.sqrt()); TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt()); }
public void testSqrt1z() { Complex z = new Complex(3, 4); Complex expected = new Complex(4.08033, -2.94094); TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5); }
public void testSqrt1zNaN() { Assert.assertTrue(Complex.NaN.sqrt1z().isNaN()); }
public void testTan() { Complex z = new Complex(3, 4); Complex expected = new Complex(-0.000187346, 0.999356); TestUtils.assertEquals(expected, z.tan(), 1.0e-5); }
public void testTanNaN() { Assert.assertTrue(Complex.NaN.tan().isNaN()); }
public void testTanInf() { TestUtils.assertSame(zeroNaN, oneInf.tan()); TestUtils.assertSame(zeroNaN, oneNegInf.tan()); TestUtils.assertSame(Complex.NaN, infOne.tan()); TestUtils.assertSame(Complex.NaN, negInfOne.tan()); TestUtils.assertSame(Complex.NaN, infInf.tan()); TestUtils.assertSame(Complex.NaN, infNegInf.tan()); TestUtils.assertSame(Complex.NaN, negInfInf.tan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tan()); }
public void testTanCritical() { TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan()); TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan()); }
public void testTanh() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.00071, 0.00490826); TestUtils.assertEquals(expected, z.tanh(), 1.0e-5); }
public void testTanhNaN() { Assert.assertTrue(Complex.NaN.tanh().isNaN()); }
public void testTanhInf() { TestUtils.assertSame(Complex.NaN, oneInf.tanh()); TestUtils.assertSame(Complex.NaN, oneNegInf.tanh()); TestUtils.assertSame(nanZero, infOne.tanh()); TestUtils.assertSame(nanZero, negInfOne.tanh()); TestUtils.assertSame(Complex.NaN, infInf.tanh()); TestUtils.assertSame(Complex.NaN, infNegInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh()); }
public void testTanhCritical() { TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh()); }
public void testMath221() { Assert.assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0))); }
public void testNthRoot_normal_thirdRoot() { // The complex number we want to compute all third-roots for. Complex z = new Complex(-2,2); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(1.0,         thirdRootsOfZ[0].getReal(),   1.0e-5); Assert.assertEquals(1.0,         thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.3660254037844386, thirdRootsOfZ[1].getReal(),   1.0e-5); Assert.assertEquals(0.36602540378443843, thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(0.366025403784439,  thirdRootsOfZ[2].getReal(),   1.0e-5); Assert.assertEquals(-1.3660254037844384, thirdRootsOfZ[2].getImaginary(), 1.0e-5); }
public void testNthRoot_normal_fourthRoot() { // The complex number we want to compute all third-roots for. Complex z = new Complex(5,-2); // The List holding all fourth roots Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(4, fourthRootsOfZ.length); // test z_0 Assert.assertEquals(1.5164629308487783,   fourthRootsOfZ[0].getReal(),   1.0e-5); Assert.assertEquals(-0.14469266210702247,  fourthRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(0.14469266210702256,  fourthRootsOfZ[1].getReal(),   1.0e-5); Assert.assertEquals(1.5164629308487783,   fourthRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-1.5164629308487783,  fourthRootsOfZ[2].getReal(),   1.0e-5); Assert.assertEquals(0.14469266210702267,  fourthRootsOfZ[2].getImaginary(), 1.0e-5); // test z_3 Assert.assertEquals(-0.14469266210702275,  fourthRootsOfZ[3].getReal(),   1.0e-5); Assert.assertEquals(-1.5164629308487783,  fourthRootsOfZ[3].getImaginary(), 1.0e-5); }
public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() { // The number 8 has three third roots. One we all already know is the number 2. // But there are two more complex roots. Complex z = new Complex(8,0); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(2.0,        thirdRootsOfZ[0].getReal(),   1.0e-5); Assert.assertEquals(0.0,        thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.0,        thirdRootsOfZ[1].getReal(),   1.0e-5); Assert.assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-1.0,        thirdRootsOfZ[2].getReal(),   1.0e-5); Assert.assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5); }
public void testNthRoot_cornercase_thirdRoot_realPartZero() { // complex number with only imaginary part Complex z = new Complex(0,2); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(1.0911236359717216,   thirdRootsOfZ[0].getReal(),   1.0e-5); Assert.assertEquals(0.6299605249474365,   thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.0911236359717216,   thirdRootsOfZ[1].getReal(),   1.0e-5); Assert.assertEquals(0.6299605249474365,   thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(),   1.0e-5); Assert.assertEquals(-1.2599210498948732,   thirdRootsOfZ[2].getImaginary(), 1.0e-5); }
public void testNthRoot_cornercase_NAN_Inf() { // NaN + finite -> NaN List<Complex> roots = oneNaN.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); roots = nanZero.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); // NaN + infinite -> NaN roots = nanInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); // finite + infinite -> Inf roots = oneInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.INF, roots.get(0)); // infinite + infinite -> Inf roots = negInfInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.INF, roots.get(0)); }
public void testGetArgument() { Complex z = new Complex(1, 0); Assert.assertEquals(0.0, z.getArgument(), 1.0e-12); z = new Complex(1, 1); Assert.assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(0, 1); Assert.assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12); z = new Complex(-1, 1); Assert.assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(-1, 0); Assert.assertEquals(FastMath.PI, z.getArgument(), 1.0e-12); z = new Complex(-1, -1); Assert.assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(0, -1); Assert.assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12); z = new Complex(1, -1); Assert.assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12); }
public void testGetArgumentInf() { Assert.assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12); Assert.assertEquals(0.0, infOne.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12); Assert.assertEquals(0.0, infZero.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12); Assert.assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12); Assert.assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12); }
public void testGetArgumentNaN() { Assert.assertTrue(Double.isNaN(nanZero.getArgument())); Assert.assertTrue(Double.isNaN(zeroNaN.getArgument())); Assert.assertTrue(Double.isNaN(Complex.NaN.getArgument())); }
public void testSerial() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(z, TestUtils.serializeAndRecover(z)); Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN); Assert.assertEquals(nanZero, ncmplx); Assert.assertTrue(ncmplx.isNaN()); Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf); Assert.assertEquals(infInf, infcmplx); Assert.assertTrue(infcmplx.isInfinite()); TestComplex tz = new TestComplex(3.0, 4.0); Assert.assertEquals(tz, TestUtils.serializeAndRecover(tz)); TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN)); Assert.assertEquals(nanZero, ntcmplx); Assert.assertTrue(ntcmplx.isNaN()); TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf)); Assert.assertEquals(infInf, inftcmplx); Assert.assertTrue(inftcmplx.isInfinite()); }
public void testSimpleNoDecimals() { Complex c = new Complex(1, 2); String expected = "1 + 2i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testTrimOneImaginary() { final ComplexFormat fmt = ComplexFormat.getInstance(getLocale()); fmt.getImaginaryFormat().setMaximumFractionDigits(1); Complex c = new Complex(1, 1.04); String expected = "1 + i"; String actual = fmt.format(c); Assert.assertEquals(expected, actual); c = new Complex(1, 1.09); expected = "1 + 1" + getDecimalCharacter() + "1i"; actual = fmt.format(c); Assert.assertEquals(expected, actual); c = new Complex(1, -1.09); expected = "1 - 1" + getDecimalCharacter() + "1i"; actual = fmt.format(c); Assert.assertEquals(expected, actual); c = new Complex(1, -1.04); expected = "1 - i"; actual = fmt.format(c); Assert.assertEquals(expected, actual); }
public void testSimpleWithDecimals() { Complex c = new Complex(1.23, 1.43); String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testSimpleWithDecimalsTrunc() { Complex c = new Complex(1.2323, 1.4343); String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testNegativeReal() { Complex c = new Complex(-1.2323, 1.4343); String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testNegativeImaginary() { Complex c = new Complex(1.2323, -1.4343); String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testNegativeBoth() { Complex c = new Complex(-1.2323, -1.4343); String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testZeroReal() { Complex c = new Complex(0.0, -1.4343); String expected = "0 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testZeroImaginary() { Complex c = new Complex(30.233, 0); String expected = "30" + getDecimalCharacter() + "23"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testDifferentImaginaryChar() { Complex c = new Complex(1, 1); String expected = "1 + j"; String actual = complexFormatJ.format(c); Assert.assertEquals(expected, actual); }
public void testDefaultFormatComplex() { Locale defaultLocal = Locale.getDefault(); Locale.setDefault(getLocale()); Complex c = new Complex(232.222, -342.33); String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i"; String actual = (new ComplexFormat()).format(c); Assert.assertEquals(expected, actual); Locale.setDefault(defaultLocal); }
public void testNan() { Complex c = new Complex(Double.NaN, Double.NaN); String expected = "(NaN) + (NaN)i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testPositiveInfinity() { Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); String expected = "(Infinity) + (Infinity)i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testNegativeInfinity() { Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); String expected = "(-Infinity) - (Infinity)i"; String actual = complexFormat.format(c); Assert.assertEquals(expected, actual); }
public void testParseSimpleNoDecimals() { String source = "1 + 1i"; Complex expected = new Complex(1, 1); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseSimpleWithDecimals() { String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; Complex expected = new Complex(1.23, 1.43); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseSimpleWithDecimalsTrunc() { String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(1.2323, 1.4343); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseNegativeReal() { String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(-1.2323, 1.4343); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseNegativeImaginary() { String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(1.2323, -1.4343); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseNegativeBoth() { String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(-1.2323, -1.4343); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseZeroReal() { String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(0.0, -1.4343); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseZeroImaginary() { String source = "-1" + getDecimalCharacter() + "2323"; Complex expected = new Complex(-1.2323, 0); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParseDifferentImaginaryChar() { String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j"; Complex expected = new Complex(-1.2323, -1.4343); Complex actual = complexFormatJ.parse(source); Assert.assertEquals(expected, actual); }
public void testParseNan() { String source = "(NaN) + (NaN)i"; Complex expected = new Complex(Double.NaN, Double.NaN); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testParsePositiveInfinity() { String source = "(Infinity) + (Infinity)i"; Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testPaseNegativeInfinity() { String source = "(-Infinity) - (Infinity)i"; Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); Complex actual = complexFormat.parse(source); Assert.assertEquals(expected, actual); }
public void testConstructorSingleFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(nf); Assert.assertNotNull(cf); Assert.assertEquals(nf, cf.getRealFormat()); }
public void testGetImaginaryFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(nf); Assert.assertSame(nf, cf.getImaginaryFormat()); }
public void testGetRealFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(nf); Assert.assertSame(nf, cf.getRealFormat()); }
public void testFormatNumber() { ComplexFormat cf = ComplexFormat.getInstance(getLocale()); Double pi = Double.valueOf(FastMath.PI); String text = cf.format(pi); Assert.assertEquals("3" + getDecimalCharacter() + "14", text); }
public void testForgottenImaginaryCharacter() { ParsePosition pos = new ParsePosition(0); Assert.assertNull(new ComplexFormat().parse("1 + 1", pos)); Assert.assertEquals(5, pos.getErrorIndex()); }
public void testPolar2Complex() { TestUtils.assertEquals(Complex.ONE, ComplexUtils.polar2Complex(1, 0), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, 1), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, -1), 10e-12); TestUtils.assertEquals(Complex.I, ComplexUtils.polar2Complex(1, pi/2), 10e-12); TestUtils.assertEquals(Complex.I.negate(), ComplexUtils.polar2Complex(1, -pi/2), 10e-12); double r = 0; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 20; j++) { theta += pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } theta = -2 * pi; for (int j =0; j < 20; j++) { theta -= pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } } }
public void testPolar2ComplexIllegalModulus() { try { ComplexUtils.polar2Complex(-1, 0); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } }
public void testPolar2ComplexNaN() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, nan)); }
public void testPolar2ComplexInf() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, negInf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, negInf)); TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4)); TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0)); TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4)); TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4)); TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4)); }
public void testZero() { Assert.assertEquals(Complex.ZERO, ComplexField.getInstance().getZero()); }
public void testOne() { Assert.assertEquals(Complex.ONE, ComplexField.getInstance().getOne()); }
public void testSerial() { // deserializing the singleton should give the singleton itself back ComplexField field = ComplexField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); }
