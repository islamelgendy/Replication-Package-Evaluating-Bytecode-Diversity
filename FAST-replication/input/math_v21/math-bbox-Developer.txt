public void testDimensions() { CholeskyDecomposition llt = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)); Assert.assertEquals(testData.length, llt.getL().getRowDimension()); Assert.assertEquals(testData.length, llt.getL().getColumnDimension()); Assert.assertEquals(testData.length, llt.getLT().getRowDimension()); Assert.assertEquals(testData.length, llt.getLT().getColumnDimension()); }
public void testNonSquare() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[3][2])); }
public void testNotSymmetricMatrixException() { double[][] changed = testData.clone(); changed[0][changed[0].length - 1] += 1.0e-5; new CholeskyDecomposition(MatrixUtils.createRealMatrix(changed)); }
public void testNotPositiveDefinite() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] { { 14, 11, 13, 15, 24 }, { 11, 34, 13, 8, 25 }, { 13, 13, 14, 15, 21 }, { 15, 8, 15, 18, 23 }, { 24, 25, 21, 23, 45 } })); }
public void testMath274() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] { { 0.40434286, -0.09376327, 0.30328980, 0.04909388 }, {-0.09376327, 0.10400408, 0.07137959, 0.04762857 }, { 0.30328980, 0.07137959, 0.30458776, 0.04882449 }, { 0.04909388, 0.04762857, 0.04882449, 0.07543265 } })); }
public void testAEqualLLT() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); CholeskyDecomposition llt = new CholeskyDecomposition(matrix); RealMatrix l = llt.getL(); RealMatrix lt = llt.getLT(); double norm = l.multiply(lt).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 1.0e-15); }
public void testLLowerTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); RealMatrix l = new CholeskyDecomposition(matrix).getL(); for (int i = 0; i < l.getRowDimension(); i++) { for (int j = i + 1; j < l.getColumnDimension(); j++) { Assert.assertEquals(0.0, l.getEntry(i, j), 0.0); } } }
public void testLTTransposed() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); CholeskyDecomposition llt = new CholeskyDecomposition(matrix); RealMatrix l = llt.getL(); RealMatrix lt = llt.getLT(); double norm = l.subtract(lt.transpose()).getNorm(); Assert.assertEquals(0, norm, 1.0e-15); }
public void testMatricesValues() { RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 0, 0, 0, 0 }, { 2, 3, 0, 0, 0 }, { 4, 5, 6, 0, 0 }, { 7, 8, 9, 10, 0 }, { 11, 12, 13, 14, 15 } }); CholeskyDecomposition llt = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)); // check values against known references RealMatrix l = llt.getL(); Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix lt = llt.getLT(); Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13); // check the same cached instance is returned the second time Assert.assertTrue(l == llt.getL()); Assert.assertTrue(lt == llt.getLT()); }
public void testDecomposition3x3() { RealMatrix m = MatrixUtils.createRealMatrix(new double[][] { { 1,  9,  9 }, { 9, 225, 225 }, { 9, 225, 625 } }); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-6); // as this decomposition permutes lines and columns, the root is NOT triangular // (in fact here it is the lower right part of the matrix which is zero and // the upper left non-zero) Assert.assertEquals(0.8, d.getRootMatrix().getEntry(0, 2), 1.0e-15); Assert.assertEquals(25.0, d.getRootMatrix().getEntry(2, 0), 1.0e-15); Assert.assertEquals(0.0, d.getRootMatrix().getEntry(2, 2), 1.0e-15); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15); }
public void testFullRank() { RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705,   0.,      0.,      0.   }, { 0.0896442724, 0.1223540781,   0.,      0.   }, { 0.0852155322, 4.558668e-3, 0.1083577299,   0.   }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15); // the pivoted Cholesky decomposition is *not* unique. Here, the root is // not equal to the original trianbular base matrix Assert.assertTrue(root.subtract(base).getNorm() > 0.3); }
public void testMath789() { final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM1 = root1.multiply(root1.transpose()); Assert.assertEquals(0.0, m1.subtract(rebuiltM1).getNorm(), 1.0e-16); final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM2 = root2.multiply(root2.transpose()); Assert.assertEquals(0.0, m2.subtract(rebuiltM2).getNorm(), 1.0e-16); final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM3 = root3.multiply(root3.transpose()); Assert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16); }
