public void testGetLine() throws IOException { final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); for (final String[] re : RESULT) { assertArrayEquals(re, parser.nextRecord().values()); } assertNull(parser.nextRecord()); }
public void testGetRecords() throws IOException { final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true)); final List<CSVRecord> records = parser.getRecords(); assertEquals(RESULT.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < RESULT.length; i++) { assertArrayEquals(RESULT[i], records.get(i).values()); } }
public void testExcelFormat1() throws IOException { final String code = "value1,value2,value3,value4\r\na,b,c,d\r\n x,,," + "\r\n\r\n\"\"\"hello\"\"\",\" \"\"world\"\"\",\"abc\ndef\",\r\n"; final String[][] res = { {"value1", "value2", "value3", "value4"}, {"a", "b", "c", "d"}, {" x", "", "", ""}, {""}, {"\"hello\"", " \"world\"", "abc\ndef", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } }
public void testExcelFormat2() throws Exception { final String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n"; final String[][] res = { {"foo", "baar"}, {""}, {"hello", ""}, {""}, {"world", ""} }; final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } }
public void testEndOfFileBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, {""}, // Excel format does not ignore empty lines {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } } }
public void testEndOfFileBehaviorCSV() throws Exception { final String[] codes = { "hello,\r\n\r\nworld,\r\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\r\n", "hello,\r\n\r\nworld,\"\"", "hello,\r\n\r\nworld,\n", "hello,\r\n\r\nworld,", "hello,\r\n\r\nworld,\"\"\n", "hello,\r\n\r\nworld,\"\"" }; final String[][] res = { {"hello", ""}, // CSV format ignores empty lines {"world", ""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } } }
public void testEmptyLineBehaviourExcel() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""}, {""}, // Excel format does not ignore empty lines {""} }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } } }
public void testEmptyLineBehaviourCSV() throws Exception { final String[] codes = { "hello,\r\n\r\n\r\n", "hello,\n\n\n", "hello,\"\"\r\n\r\n\r\n", "hello,\"\"\n\n\n" }; final String[][] res = { {"hello", ""} // CSV format ignores empty lines }; for (final String code : codes) { final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } } }
public void testEmptyFile() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); assertNull(parser.nextRecord()); }
public void testCSV57() throws Exception { final CSVParser parser = CSVParser.parse("", CSVFormat.DEFAULT); final List<CSVRecord> list = parser.getRecords(); assertNotNull(list); assertEquals(0, list.size()); }
public void testBackslashEscapingOld() throws IOException { final String code = "one,two,three\n" + "on\\\"e,two\n" + "on\"e,two\n" + "one,\"tw\\\"o\"\n" + "one,\"t\\,wo\"\n" + "one,two,\"th,ree\"\n" + "\"a\\\\\"\n" + "a\\,b\n" + "\"a\\\\,b\""; final String[][] res = { {"one", "two", "three"}, {"on\\\"e", "two"}, {"on\"e", "two"}, {"one", "tw\"o"}, {"one", "t\\,wo"}, // backslash in quotes only escapes a delimiter (",") {"one", "two", "th,ree"}, {"a\\\\"},   // backslash in quotes only escapes a delimiter (",") {"a\\", "b"}, // a backslash must be returnd {"a\\\\,b"}  // backslash in quotes only escapes a delimiter (",") }; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(res.length, records.size()); assertTrue(records.size() > 0); for (int i = 0; i < res.length; i++) { assertArrayEquals(res[i], records.get(i).values()); } }
public void testBackslashEscaping() throws IOException { // To avoid confusion over the need for escaping chars in java code, // We will test with a forward slash as the escape char, and a single // quote as the encapsulator. final String code = "one,two,three\n" // 0 + "'',''\n"    // 1) empty encapsulators + "/',/'\n"    // 2) single encapsulators + "'/'','/''\n"  // 3) single encapsulators encapsulated via escape + "'''',''''\n"  // 4) single encapsulators encapsulated via doubling + "/,,/,\n"    // 5) separator escaped + "//,//\n"    // 6) escape escaped + "'//','//'\n"  // 7) escape escaped in encapsulation + "  8  ,  \"quoted \"\" /\" // string\"  \n"   // don't eat spaces + "9,  /\n  \n" // escaped newline + ""; final String[][] res = { {"one", "two", "three"}, // 0 {"", ""},        // 1 {"'", "'"},       // 2 {"'", "'"},       // 3 {"'", "'"},       // 4 {",", ","},       // 5 {"/", "/"},       // 6 {"/", "/"},       // 7 {"  8  ", "  \"quoted \"\" /\" / string\"  "}, {"9", "  \n  "}, };  final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\'') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); assertTrue(records.size() > 0); Utils.compare("Records do not match expected result", res, records); }
public void testBackslashEscaping2() throws IOException { // To avoid confusion over the need for escaping chars in java code, // We will test with a forward slash as the escape char, and a single // quote as the encapsulator. final String code = "" + " , , \n"      // 1) + " \t , , \n"    // 2) + " // , /, , /,\n"  // 3) + ""; final String[][] res = { {" ", " ", " "},     // 1 {" \t ", " ", " "},   // 2 {" / ", " , ", " ,"},  // 3 };  final CSVFormat format = CSVFormat.newFormat(',') .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true); final CSVParser parser = CSVParser.parse(code, format); final List<CSVRecord> records = parser.getRecords(); assertTrue(records.size() > 0); Utils.compare("", res, records); }
public void testDefaultFormat() throws IOException { final String code = "" + "a,b#\n"      // 1) + "\"\n\",\" \",#\n"  // 2) + "#,\"\"\n"     // 3) + "# Final comment\n"// 4) ; final String[][] res = { {"a", "b#"}, {"\n", " ", "#"}, {"#", ""}, {"# Final comment"} }; CSVFormat format = CSVFormat.DEFAULT; assertFalse(format.isCommentingEnabled()); CSVParser parser = CSVParser.parse(code, format); List<CSVRecord> records = parser.getRecords(); assertTrue(records.size() > 0); Utils.compare("Failed to parse without comments", res, records); final String[][] res_comments = { {"a", "b#"}, {"\n", " ", "#"}, }; format = CSVFormat.DEFAULT.withCommentStart('#'); parser = CSVParser.parse(code, format); records = parser.getRecords(); Utils.compare("Failed to parse with comments", res_comments, records); }
public void testCarriageReturnLineFeedEndings() throws IOException { final String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(4, records.size()); }
public void testClose() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in); final Iterator<CSVRecord> records = parser.iterator(); assertTrue(records.hasNext()); parser.close(); assertFalse(records.hasNext()); records.next(); }
public void testCarriageReturnEndings() throws IOException { final String code = "foo\rbaar,\rhello,world\r,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(4, records.size()); }
public void testLineFeedEndings() throws IOException { final String code = "foo\nbaar,\nhello,world\n,kanu"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(4, records.size()); }
public void testIgnoreEmptyLines() throws IOException { final String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n"; //String code = "world\r\n\n"; //String code = "foo;baar\r\n\r\nhello;\r\n\r\nworld;\r\n"; final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT); final List<CSVRecord> records = parser.getRecords(); assertEquals(3, records.size()); }
public void testForEach() throws Exception { final List<CSVRecord> records = new ArrayList<CSVRecord>(); final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) { records.add(record); } assertEquals(3, records.size()); assertArrayEquals(new String[]{"a", "b", "c"}, records.get(0).values()); assertArrayEquals(new String[]{"1", "2", "3"}, records.get(1).values()); assertArrayEquals(new String[]{"x", "y", "z"}, records.get(2).values()); }
public void testRoundtrip() throws Exception { final StringWriter out = new StringWriter(); final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT); final String input = "a,b,c\r\n1,2,3\r\nx,y,z\r\n"; for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) { printer.printRecord(record); } assertEquals(input, out.toString()); printer.close(); }
public void testIterator() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator(); assertTrue(iterator.hasNext()); try { iterator.remove(); fail("expected UnsupportedOperationException"); } catch (final UnsupportedOperationException expected) { // expected } assertArrayEquals(new String[]{"a", "b", "c"}, iterator.next().values()); assertArrayEquals(new String[]{"1", "2", "3"}, iterator.next().values()); assertTrue(iterator.hasNext()); assertTrue(iterator.hasNext()); assertTrue(iterator.hasNext()); assertArrayEquals(new String[]{"x", "y", "z"}, iterator.next().values()); assertFalse(iterator.hasNext()); try { iterator.next(); fail("NoSuchElementException expected"); } catch (final NoSuchElementException e) { // expected } }
public void testMultipleIterators() throws Exception { CSVParser parser = CSVParser.parse("a,b,c" + CR + "d,e,f", CSVFormat.DEFAULT); Iterator<CSVRecord> itr1 = parser.iterator(); Iterator<CSVRecord> itr2 = parser.iterator(); CSVRecord first = itr1.next(); assertEquals("a", first.get(0)); assertEquals("b", first.get(1)); assertEquals("c", first.get(2)); CSVRecord second = itr2.next(); assertEquals("d", second.get(0)); assertEquals("e", second.get(1)); assertEquals("f", second.get(2)); }
public void testHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { assertTrue(records.hasNext()); final CSVRecord record = records.next(); assertEquals(record.get(0), record.get("a")); assertEquals(record.get(1), record.get("b")); assertEquals(record.get(2), record.get("c")); } assertFalse(records.hasNext()); }
public void testSkipSetHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("a", "b", "c").withSkipHeaderRecord(true) .parse(in).iterator(); final CSVRecord record = records.next(); assertEquals("1", record.get("a")); assertEquals("2", record.get("b")); assertEquals("3", record.get("c")); }
public void testSkipAutoHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); final CSVRecord record = records.next(); assertEquals("1", record.get("a")); assertEquals("2", record.get("b")); assertEquals("3", record.get("c")); }
public void testHeaderComment() throws Exception { final Reader in = new StringReader("# comment\na,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { assertTrue(records.hasNext()); final CSVRecord record = records.next(); assertEquals(record.get(0), record.get("a")); assertEquals(record.get(1), record.get("b")); assertEquals(record.get(2), record.get("c")); } assertFalse(records.hasNext()); }
public void testProvidedHeader() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator(); for (int i = 0; i < 3; i++) { assertTrue(records.hasNext()); final CSVRecord record = records.next(); assertTrue(record.isMapped("A")); assertTrue(record.isMapped("B")); assertTrue(record.isMapped("C")); assertFalse(record.isMapped("NOT MAPPED")); assertEquals(record.get(0), record.get("A")); assertEquals(record.get(1), record.get("B")); assertEquals(record.get(2), record.get("C")); } assertFalse(records.hasNext()); }
public void testProvidedHeaderAuto() throws Exception { final Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator(); for (int i = 0; i < 2; i++) { assertTrue(records.hasNext()); final CSVRecord record = records.next(); assertTrue(record.isMapped("a")); assertTrue(record.isMapped("b")); assertTrue(record.isMapped("c")); assertFalse(record.isMapped("NOT MAPPED")); assertEquals(record.get(0), record.get("a")); assertEquals(record.get(1), record.get("b")); assertEquals(record.get(2), record.get("c")); } assertFalse(records.hasNext()); }
public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception { final Reader in = new StringReader("a,b,c\n1,2\nx,y,z"); final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").withSkipHeaderRecord(true) .parse(in).iterator(); CSVRecord record; // 1st record record = records.next(); assertTrue(record.isMapped("A")); assertTrue(record.isMapped("B")); assertTrue(record.isMapped("C")); assertTrue(record.isSet("A")); assertTrue(record.isSet("B")); assertFalse(record.isSet("C")); assertEquals("1", record.get("A")); assertEquals("2", record.get("B")); assertFalse(record.isConsistent()); // 2nd record record = records.next(); assertTrue(record.isMapped("A")); assertTrue(record.isMapped("B")); assertTrue(record.isMapped("C")); assertTrue(record.isSet("A")); assertTrue(record.isSet("B")); assertTrue(record.isSet("C")); assertEquals("x", record.get("A")); assertEquals("y", record.get("B")); assertEquals("z", record.get("C")); assertTrue(record.isConsistent()); assertFalse(records.hasNext()); }
public void testGetHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT.withHeader("A", "B", "C")); final Map<String, Integer> headerMap = parser.getHeaderMap(); final Iterator<String> columnNames = headerMap.keySet().iterator(); // Headers are iterated in column order. Assert.assertEquals("A", columnNames.next()); Assert.assertEquals("B", columnNames.next()); Assert.assertEquals("C", columnNames.next()); final Iterator<CSVRecord> records = parser.iterator(); // Parse to make sure getHeaderMap did not have a side-effect. for (int i = 0; i < 3; i++) { assertTrue(records.hasNext()); final CSVRecord record = records.next(); assertEquals(record.get(0), record.get("A")); assertEquals(record.get(1), record.get("B")); assertEquals(record.get(2), record.get("C")); } assertFalse(records.hasNext()); }
public void testNoHeaderMap() throws Exception { final CSVParser parser = CSVParser.parse("a,b,c\n1,2,3\nx,y,z", CSVFormat.DEFAULT); Assert.assertNull(parser.getHeaderMap()); }
public void testGetLineNumberWithLF() throws Exception { this.validateLineNumbers(String.valueOf(LF)); }
public void testGetLineNumberWithCRLF() throws Exception { this.validateLineNumbers(CRLF); }
public void testGetLineNumberWithCR() throws Exception { this.validateLineNumbers(String.valueOf(CR)); }
public void testGetRecordNumberWithLF() throws Exception { this.validateRecordNumbers(String.valueOf(LF)); }
public void testGetRecordWithMultiLineValues() throws Exception { final CSVParser parser = CSVParser.parse("\"a\r\n1\",\"a\r\n2\"" + CRLF + "\"b\r\n1\",\"b\r\n2\"" + CRLF + "\"c\r\n1\",\"c\r\n2\"", CSVFormat.DEFAULT.withRecordSeparator(CRLF)); CSVRecord record; assertEquals(0, parser.getRecordNumber()); assertEquals(0, parser.getCurrentLineNumber()); assertNotNull(record = parser.nextRecord()); assertEquals(3, parser.getCurrentLineNumber()); assertEquals(1, record.getRecordNumber()); assertEquals(1, parser.getRecordNumber()); assertNotNull(record = parser.nextRecord()); assertEquals(6, parser.getCurrentLineNumber()); assertEquals(2, record.getRecordNumber()); assertEquals(2, parser.getRecordNumber()); assertNotNull(record = parser.nextRecord()); assertEquals(8, parser.getCurrentLineNumber()); assertEquals(3, record.getRecordNumber()); assertEquals(3, parser.getRecordNumber()); assertNull(record = parser.nextRecord()); assertEquals(8, parser.getCurrentLineNumber()); assertEquals(3, parser.getRecordNumber()); }
public void testGetRecordNumberWithCRLF() throws Exception { this.validateRecordNumbers(CRLF); }
public void testGetRecordNumberWithCR() throws Exception { this.validateRecordNumbers(String.valueOf(CR)); }
public void testInvalidFormat() throws Exception { final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR); new CSVParser(null, invalidFormat).close(); }
public void testParseNullFileFormat() throws Exception { CSVParser.parse((File) null, CSVFormat.DEFAULT); }
public void testParseFileNullFormat() throws Exception { CSVParser.parse(new File(""), null); }
public void testParseNullStringFormat() throws Exception { CSVParser.parse((String) null, CSVFormat.DEFAULT); }
public void testParseStringNullFormat() throws Exception { CSVParser.parse("csv data", null); }
public void testParseNullUrlCharsetFormat() throws Exception { CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT); }
public void testParserUrlNullCharsetFormat() throws Exception { CSVParser.parse(new URL("http://commons.apache.org"), null, CSVFormat.DEFAULT); }
public void testParseUrlCharsetNullFormat() throws Exception { CSVParser.parse(new URL("http://commons.apache.org"), Charset.defaultCharset(), null); }
public void testNewCSVParserNullReaderFormat() throws Exception { new CSVParser(null, CSVFormat.DEFAULT); }
public void testNewCSVParserReaderNullFormat() throws Exception { new CSVParser(new StringReader(""), null); }
