public void testGoldenRatio() throws Exception { ContinuedFraction cf = new ContinuedFraction() { @Override public double getA(int n, double x) { return 1.0; } @Override public double getB(int n, double x) { return 1.0; } }; double gr = cf.evaluate(0.0, 10e-9); Assert.assertEquals(1.61803399, gr, 10e-9); }
public void testZero() { Assert.assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero()); }
public void testOne() { Assert.assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne()); }
public void testSerial() { // deserializing the singleton should give the singleton itself back BigFractionField field = BigFractionField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); }
public void testZero() { Assert.assertEquals(Fraction.ZERO, FractionField.getInstance().getZero()); }
public void testOne() { Assert.assertEquals(Fraction.ONE, FractionField.getInstance().getOne()); }
public void testSerial() { // deserializing the singleton should give the singleton itself back FractionField field = FractionField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); }
public void testConstructor() { assertFraction(0, 1, new Fraction(0, 1)); assertFraction(0, 1, new Fraction(0, 2)); assertFraction(0, 1, new Fraction(0, -1)); assertFraction(1, 2, new Fraction(1, 2)); assertFraction(1, 2, new Fraction(2, 4)); assertFraction(-1, 2, new Fraction(-1, 2)); assertFraction(-1, 2, new Fraction(1, -2)); assertFraction(-1, 2, new Fraction(-2, 4)); assertFraction(-1, 2, new Fraction(2, -4)); // overflow try { new Fraction(Integer.MIN_VALUE, -1); Assert.fail(); } catch (MathArithmeticException ex) { // success } try { new Fraction(1, Integer.MIN_VALUE); Assert.fail(); } catch (MathArithmeticException ex) { // success } assertFraction(0, 1, new Fraction(0.00000000000001)); assertFraction(2, 5, new Fraction(0.40000000000001)); assertFraction(15, 1, new Fraction(15.0000000000001)); }
public void testGoldenRatio() { // the golden ratio is notoriously a difficult number for continuous fraction new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25); }
public void testDoubleConstructor() throws ConvergenceException { assertFraction(1, 2, new Fraction((double)1 / (double)2)); assertFraction(1, 3, new Fraction((double)1 / (double)3)); assertFraction(2, 3, new Fraction((double)2 / (double)3)); assertFraction(1, 4, new Fraction((double)1 / (double)4)); assertFraction(3, 4, new Fraction((double)3 / (double)4)); assertFraction(1, 5, new Fraction((double)1 / (double)5)); assertFraction(2, 5, new Fraction((double)2 / (double)5)); assertFraction(3, 5, new Fraction((double)3 / (double)5)); assertFraction(4, 5, new Fraction((double)4 / (double)5)); assertFraction(1, 6, new Fraction((double)1 / (double)6)); assertFraction(5, 6, new Fraction((double)5 / (double)6)); assertFraction(1, 7, new Fraction((double)1 / (double)7)); assertFraction(2, 7, new Fraction((double)2 / (double)7)); assertFraction(3, 7, new Fraction((double)3 / (double)7)); assertFraction(4, 7, new Fraction((double)4 / (double)7)); assertFraction(5, 7, new Fraction((double)5 / (double)7)); assertFraction(6, 7, new Fraction((double)6 / (double)7)); assertFraction(1, 8, new Fraction((double)1 / (double)8)); assertFraction(3, 8, new Fraction((double)3 / (double)8)); assertFraction(5, 8, new Fraction((double)5 / (double)8)); assertFraction(7, 8, new Fraction((double)7 / (double)8)); assertFraction(1, 9, new Fraction((double)1 / (double)9)); assertFraction(2, 9, new Fraction((double)2 / (double)9)); assertFraction(4, 9, new Fraction((double)4 / (double)9)); assertFraction(5, 9, new Fraction((double)5 / (double)9)); assertFraction(7, 9, new Fraction((double)7 / (double)9)); assertFraction(8, 9, new Fraction((double)8 / (double)9)); assertFraction(1, 10, new Fraction((double)1 / (double)10)); assertFraction(3, 10, new Fraction((double)3 / (double)10)); assertFraction(7, 10, new Fraction((double)7 / (double)10)); assertFraction(9, 10, new Fraction((double)9 / (double)10)); assertFraction(1, 11, new Fraction((double)1 / (double)11)); assertFraction(2, 11, new Fraction((double)2 / (double)11)); assertFraction(3, 11, new Fraction((double)3 / (double)11)); assertFraction(4, 11, new Fraction((double)4 / (double)11)); assertFraction(5, 11, new Fraction((double)5 / (double)11)); assertFraction(6, 11, new Fraction((double)6 / (double)11)); assertFraction(7, 11, new Fraction((double)7 / (double)11)); assertFraction(8, 11, new Fraction((double)8 / (double)11)); assertFraction(9, 11, new Fraction((double)9 / (double)11)); assertFraction(10, 11, new Fraction((double)10 / (double)11)); }
public void testDigitLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4,  9)); assertFraction(2, 5, new Fraction(0.4, 99)); assertFraction(2, 5, new Fraction(0.4, 999)); assertFraction(3, 5,   new Fraction(0.6152,  9)); assertFraction(8, 13,   new Fraction(0.6152,  99)); assertFraction(510, 829, new Fraction(0.6152, 999)); assertFraction(769, 1250, new Fraction(0.6152, 9999)); }
public void testIntegerOverflow() { checkIntegerOverflow(0.75000000001455192); checkIntegerOverflow(1.0e10); }
public void testEpsilonLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100)); assertFraction(3, 5,   new Fraction(0.6152, 0.02, 100)); assertFraction(8, 13,   new Fraction(0.6152, 1.0e-3, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-4, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-5, 100)); assertFraction(510, 829, new Fraction(0.6152, 1.0e-6, 100)); assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100)); }
public void testCompareTo() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Fraction third = new Fraction(1, 2); Assert.assertEquals(0, first.compareTo(first)); Assert.assertEquals(0, first.compareTo(third)); Assert.assertEquals(1, first.compareTo(second)); Assert.assertEquals(-1, second.compareTo(first)); // these two values are different approximations of PI // the first one is approximately PI - 3.07e-18 // the second one is approximately PI + 1.936e-17 Fraction pi1 = new Fraction(1068966896, 340262731); Fraction pi2 = new Fraction( 411557987, 131002976); Assert.assertEquals(-1, pi1.compareTo(pi2)); Assert.assertEquals( 1, pi2.compareTo(pi1)); Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20); }
public void testDoubleValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Assert.assertEquals(0.5, first.doubleValue(), 0.0); Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0); }
public void testFloatValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Assert.assertEquals(0.5f, first.floatValue(), 0.0f); Assert.assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f); }
public void testIntValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); Assert.assertEquals(0, first.intValue()); Assert.assertEquals(1, second.intValue()); }
public void testLongValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); Assert.assertEquals(0L, first.longValue()); Assert.assertEquals(1L, second.longValue()); }
public void testConstructorDouble() { assertFraction(1, 2, new Fraction(0.5)); assertFraction(1, 3, new Fraction(1.0 / 3.0)); assertFraction(17, 100, new Fraction(17.0 / 100.0)); assertFraction(317, 100, new Fraction(317.0 / 100.0)); assertFraction(-1, 2, new Fraction(-0.5)); assertFraction(-1, 3, new Fraction(-1.0 / 3.0)); assertFraction(-17, 100, new Fraction(17.0 / -100.0)); assertFraction(-317, 100, new Fraction(-317.0 / 100.0)); }
public void testAbs() { Fraction a = new Fraction(10, 21); Fraction b = new Fraction(-10, 21); Fraction c = new Fraction(10, -21); assertFraction(10, 21, a.abs()); assertFraction(10, 21, b.abs()); assertFraction(10, 21, c.abs()); }
public void testPercentage() { Assert.assertEquals(50.0, new Fraction(1, 2).percentageValue(), 1.0e-15); }
public void testMath835() { final int numer = Integer.MAX_VALUE / 99; final int denom = 1; final double percentage = 100 * ((double) numer) / denom; final Fraction frac = new Fraction(numer, denom); // With the implementation that preceded the fix suggested in MATH-835, // this test was failing, due to overflow. Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage)); }
public void testReciprocal() { Fraction f = null; f = new Fraction(50, 75); f = f.reciprocal(); Assert.assertEquals(3, f.getNumerator()); Assert.assertEquals(2, f.getDenominator()); f = new Fraction(4, 3); f = f.reciprocal(); Assert.assertEquals(3, f.getNumerator()); Assert.assertEquals(4, f.getDenominator()); f = new Fraction(-15, 47); f = f.reciprocal(); Assert.assertEquals(-47, f.getNumerator()); Assert.assertEquals(15, f.getDenominator()); f = new Fraction(0, 3); try { f = f.reciprocal(); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} // large values f = new Fraction(Integer.MAX_VALUE, 1); f = f.reciprocal(); Assert.assertEquals(1, f.getNumerator()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator()); }
public void testNegate() { Fraction f = null; f = new Fraction(50, 75); f = f.negate(); Assert.assertEquals(-2, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f = new Fraction(-50, 75); f = f.negate(); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); // large values f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE); f = f.negate(); Assert.assertEquals(Integer.MIN_VALUE+2, f.getNumerator()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator()); f = new Fraction(Integer.MIN_VALUE, 1); try { f = f.negate(); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} }
public void testAdd() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.add(a)); assertFraction(7, 6, a.add(b)); assertFraction(7, 6, b.add(a)); assertFraction(4, 3, b.add(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1); Fraction f2 = Fraction.ONE; Fraction f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f = f1.add(1); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f1 = new Fraction(-1, 13*13*2*2); f2 = new Fraction(-2, 13*17*2); f = f1.add(f2); Assert.assertEquals(13*13*17*2*2, f.getDenominator()); Assert.assertEquals(-17 - 2*13*2, f.getNumerator()); try { f.add(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = new Fraction(1,32768*3); f2 = new Fraction(1,59049); f = f1.add(f2); Assert.assertEquals(52451, f.getNumerator()); Assert.assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3); f = f1.add(f2); Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE - 1, 1); f2 = Fraction.ONE; f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f = f.add(Fraction.ONE); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(-1,5); try { f = f1.add(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.add(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} }
public void testDivide() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.divide(a)); assertFraction(3, 4, a.divide(b)); assertFraction(4, 3, b.divide(a)); assertFraction(1, 1, b.divide(b)); Fraction f1 = new Fraction(3, 5); Fraction f2 = Fraction.ZERO; try { f1.divide(f2); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(0, 5); f2 = new Fraction(2, 7); Fraction f = f1.divide(f2); Assert.assertSame(Fraction.ZERO, f); f1 = new Fraction(2, 7); f2 = Fraction.ONE; f = f1.divide(f2); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(7, f.getDenominator()); f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1); Assert.assertEquals(1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f.divide(null); Assert.fail("MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} try { f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f1 = new Fraction(1, -Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(6, 35); f = f1.divide(15); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(175, f.getDenominator()); }
public void testMultiply() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 4, a.multiply(a)); assertFraction(1, 3, a.multiply(b)); assertFraction(1, 3, b.multiply(a)); assertFraction(4, 9, b.multiply(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE, 1); Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); Fraction f = f1.multiply(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f.multiply(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} f1 = new Fraction(6, 35); f = f1.multiply(15); Assert.assertEquals(18, f.getNumerator()); Assert.assertEquals(7, f.getDenominator()); }
public void testSubtract() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); Fraction f = new Fraction(1,1); try { f.subtract(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // if this fraction is subtracted naively, it will overflow. // check that it doesn't. Fraction f1 = new Fraction(1,32768*3); Fraction f2 = new Fraction(1,59049); f = f1.subtract(f2); Assert.assertEquals(-13085, f.getNumerator()); Assert.assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3).negate(); f = f1.subtract(f2); Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE, 1); f2 = Fraction.ONE; f = f1.subtract(f2); Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f = f1.subtract(1); Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f1 = new Fraction(1, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE - 1); f = f1.subtract(f2); Assert.fail("expecting MathArithmeticException"); //should overflow } catch (MathArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(1,5); try { f = f1.subtract(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} try { f= new Fraction(Integer.MIN_VALUE, 1); f = f.subtract(Fraction.ONE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f= new Fraction(Integer.MAX_VALUE, 1); f = f.subtract(Fraction.ONE.negate()); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.subtract(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} }
public void testEqualsAndHashCode() { Fraction zero = new Fraction(0,1); Fraction nullFraction = null; Assert.assertTrue( zero.equals(zero)); Assert.assertFalse(zero.equals(nullFraction)); Assert.assertFalse(zero.equals(Double.valueOf(0))); Fraction zero2 = new Fraction(0,2); Assert.assertTrue(zero.equals(zero2)); Assert.assertEquals(zero.hashCode(), zero2.hashCode()); Fraction one = new Fraction(1,1); Assert.assertFalse((one.equals(zero) ||zero.equals(one))); }
public void testGetReducedFraction() { Fraction threeFourths = new Fraction(3, 4); Assert.assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8))); Assert.assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1))); try { Fraction.getReducedFraction(1, 0); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // expected } Assert.assertEquals(Fraction.getReducedFraction (2, Integer.MIN_VALUE).getNumerator(),-1); Assert.assertEquals(Fraction.getReducedFraction (1, -1).getNumerator(), -1); }
public void testToString() { Assert.assertEquals("0", new Fraction(0, 3).toString()); Assert.assertEquals("3", new Fraction(6, 2).toString()); Assert.assertEquals("2 / 3", new Fraction(18, 27).toString()); }
public void testSerial() throws FractionConversionException { Fraction[] fractions = { new Fraction(3, 4), Fraction.ONE, Fraction.ZERO, new Fraction(17), new Fraction(FastMath.PI, 1000), new Fraction(-5, 2) }; for (Fraction fraction : fractions) { Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction)); } }
public void testFormat() { BigFraction c = new BigFraction(1, 2); String expected = "1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatNegative() { BigFraction c = new BigFraction(-1, 2); String expected = "-1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatZero() { BigFraction c = new BigFraction(0, 1); String expected = "0 / 1"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatImproper() { BigFraction c = new BigFraction(5, 3); String actual = properFormat.format(c); Assert.assertEquals("1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("5 / 3", actual); }
public void testFormatImproperNegative() { BigFraction c = new BigFraction(-5, 3); String actual = properFormat.format(c); Assert.assertEquals("-1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("-5 / 3", actual); }
public void testParse() { String source = "1 / 2"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.ONE, c.getNumerator()); Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.ONE, c.getNumerator()); Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator()); } }
public void testParseInteger() { String source = "10"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.TEN, c.getNumerator()); Assert.assertEquals(BigInteger.ONE, c.getDenominator()); } { BigFraction c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.TEN, c.getNumerator()); Assert.assertEquals(BigInteger.ONE, c.getDenominator()); } }
public void testParseInvalid() { String source = "a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } }
public void testParseInvalidDenominator() { String source = "10 / a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } }
public void testParseNegative() { { String source = "-1 / 2"; BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); source = "1 / -2"; c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); } }
public void testParseProper() { String source = "1 2 / 3"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(5, c.getNumeratorAsInt()); Assert.assertEquals(3, c.getDenominatorAsInt()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } }
public void testParseProperNegative() { String source = "-1 2 / 3"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-5, c.getNumeratorAsInt()); Assert.assertEquals(3, c.getDenominatorAsInt()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } }
public void testParseProperInvalidMinus() { String source = "2 -2 / 3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } source = "2 2 / -3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } }
public void testParseBig() { BigFraction f1 = improperFormat.parse("167213075789791382630275400487886041651764456874403" + " / " + "53225575123090058458126718248444563466137046489291"); Assert.assertEquals(FastMath.PI, f1.doubleValue(), 0.0); BigFraction f2 = properFormat.parse("3 " + "7536350420521207255895245742552351253353317406530" + " / " + "53225575123090058458126718248444563466137046489291"); Assert.assertEquals(FastMath.PI, f2.doubleValue(), 0.0); Assert.assertEquals(f1, f2); BigDecimal pi = new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068"); Assert.assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN)); }
public void testNumeratorFormat() { NumberFormat old = properFormat.getNumeratorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, properFormat.getNumeratorFormat()); properFormat.setNumeratorFormat(old); old = improperFormat.getNumeratorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, improperFormat.getNumeratorFormat()); improperFormat.setNumeratorFormat(old); }
public void testDenominatorFormat() { NumberFormat old = properFormat.getDenominatorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, properFormat.getDenominatorFormat()); properFormat.setDenominatorFormat(old); old = improperFormat.getDenominatorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, improperFormat.getDenominatorFormat()); improperFormat.setDenominatorFormat(old); }
public void testWholeFormat() { ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat; NumberFormat old = format.getWholeFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); format.setWholeFormat(nf); Assert.assertEquals(nf, format.getWholeFormat()); format.setWholeFormat(old); }
public void testLongFormat() { Assert.assertEquals("10 / 1", improperFormat.format(10l)); }
public void testDoubleFormat() { Assert.assertEquals("1 / 16", improperFormat.format(0.0625)); }
public void testFormat() { Fraction c = new Fraction(1, 2); String expected = "1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatNegative() { Fraction c = new Fraction(-1, 2); String expected = "-1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatZero() { Fraction c = new Fraction(0, 1); String expected = "0 / 1"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); }
public void testFormatImproper() { Fraction c = new Fraction(5, 3); String actual = properFormat.format(c); Assert.assertEquals("1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("5 / 3", actual); }
public void testFormatImproperNegative() { Fraction c = new Fraction(-5, 3); String actual = properFormat.format(c); Assert.assertEquals("-1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("-5 / 3", actual); }
public void testParse() { String source = "1 / 2"; try { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); } catch (MathParseException ex) { Assert.fail(ex.getMessage()); } }
public void testParseInteger() { String source = "10"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(10, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } { Fraction c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(10, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } }
public void testParseOne1() { String source = "1 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); }
public void testParseOne2() { String source = "10 / 10"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); }
public void testParseZero1() { String source = "0 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(0, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); }
public void testParseZero2() { String source = "-0 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(0, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); // This test shows that the sign is not preserved. Assert.assertEquals(Double.POSITIVE_INFINITY, 1d / c.doubleValue(), 0); }
public void testParseInvalid() { String source = "a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } }
public void testParseInvalidDenominator() { String source = "10 / a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } }
public void testParseNegative() { { String source = "-1 / 2"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); source = "1 / -2"; c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); } }
public void testParseProper() { String source = "1 2 / 3"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(5, c.getNumerator()); Assert.assertEquals(3, c.getDenominator()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } }
public void testParseProperNegative() { String source = "-1 2 / 3"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-5, c.getNumerator()); Assert.assertEquals(3, c.getDenominator()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } }
public void testParseProperInvalidMinus() { String source = "2 -2 / 3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } source = "2 2 / -3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } }
public void testNumeratorFormat() { NumberFormat old = properFormat.getNumeratorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, properFormat.getNumeratorFormat()); properFormat.setNumeratorFormat(old); old = improperFormat.getNumeratorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, improperFormat.getNumeratorFormat()); improperFormat.setNumeratorFormat(old); }
public void testDenominatorFormat() { NumberFormat old = properFormat.getDenominatorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, properFormat.getDenominatorFormat()); properFormat.setDenominatorFormat(old); old = improperFormat.getDenominatorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, improperFormat.getDenominatorFormat()); improperFormat.setDenominatorFormat(old); }
public void testWholeFormat() { ProperFractionFormat format = (ProperFractionFormat)properFormat; NumberFormat old = format.getWholeFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); format.setWholeFormat(nf); Assert.assertEquals(nf, format.getWholeFormat()); format.setWholeFormat(old); }
public void testLongFormat() { Assert.assertEquals("10 / 1", improperFormat.format(10l)); }
public void testDoubleFormat() { Assert.assertEquals("355 / 113", improperFormat.format(FastMath.PI)); }
public void testConstructor() { assertFraction(0, 1, new BigFraction(0, 1)); assertFraction(0, 1, new BigFraction(0l, 2l)); assertFraction(0, 1, new BigFraction(0, -1)); assertFraction(1, 2, new BigFraction(1, 2)); assertFraction(1, 2, new BigFraction(2, 4)); assertFraction(-1, 2, new BigFraction(-1, 2)); assertFraction(-1, 2, new BigFraction(1, -2)); assertFraction(-1, 2, new BigFraction(-2, 4)); assertFraction(-1, 2, new BigFraction(2, -4)); assertFraction(11, 1, new BigFraction(11)); assertFraction(11, 1, new BigFraction(11l)); assertFraction(11, 1, new BigFraction(new BigInteger("11"))); assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100)); assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100)); assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100)); Assert.assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0); Assert.assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0); Assert.assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0); assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001)); assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001)); try { new BigFraction(null, BigInteger.ONE); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException npe) { // expected } try { new BigFraction(BigInteger.ONE, null); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException npe) { // expected } try { new BigFraction(BigInteger.ONE, BigInteger.ZERO); Assert.fail("Expecting ZeroException"); } catch (ZeroException npe) { // expected } try { new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000); Assert.fail("Expecting FractionConversionException"); } catch (FractionConversionException fce) { // expected } }
public void testGoldenRatio() { // the golden ratio is notoriously a difficult number for continuous fraction new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25); }
public void testDoubleConstructor() throws ConvergenceException { assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100)); assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100)); assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100)); assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100)); assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100)); assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100)); assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100)); assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100)); assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100)); assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100)); assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100)); assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100)); assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100)); assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100)); assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100)); assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100)); assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100)); assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100)); assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100)); assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100)); assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100)); assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100)); assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100)); assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100)); assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100)); assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100)); assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100)); assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100)); assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100)); assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100)); assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100)); assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100)); assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100)); assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100)); assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100)); assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100)); assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100)); assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100)); assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100)); assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100)); assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100)); }
public void testDigitLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new BigFraction(0.4, 9)); assertFraction(2, 5, new BigFraction(0.4, 99)); assertFraction(2, 5, new BigFraction(0.4, 999)); assertFraction(3, 5, new BigFraction(0.6152, 9)); assertFraction(8, 13, new BigFraction(0.6152, 99)); assertFraction(510, 829, new BigFraction(0.6152, 999)); assertFraction(769, 1250, new BigFraction(0.6152, 9999)); }
public void testEpsilonLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100)); assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100)); assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100)); assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100)); assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100)); assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100)); assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100)); }
public void testCompareTo() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); BigFraction third = new BigFraction(1, 2); Assert.assertEquals(0, first.compareTo(first)); Assert.assertEquals(0, first.compareTo(third)); Assert.assertEquals(1, first.compareTo(second)); Assert.assertEquals(-1, second.compareTo(first)); // these two values are different approximations of PI // the first one is approximately PI - 3.07e-18 // the second one is approximately PI + 1.936e-17 BigFraction pi1 = new BigFraction(1068966896, 340262731); BigFraction pi2 = new BigFraction( 411557987, 131002976); Assert.assertEquals(-1, pi1.compareTo(pi2)); Assert.assertEquals( 1, pi2.compareTo(pi1)); Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20); }
public void testDoubleValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); Assert.assertEquals(0.5, first.doubleValue(), 0.0); Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0); }
public void testDoubleValueForLargeNumeratorAndDenominator() { final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); Assert.assertEquals(5, large.doubleValue(), 1e-15); }
public void testFloatValueForLargeNumeratorAndDenominator() { final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); Assert.assertEquals(5, large.floatValue(), 1e-15); }
public void testFloatValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); Assert.assertEquals(0.5f, first.floatValue(), 0.0f); Assert.assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f); }
public void testIntValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(3, 2); Assert.assertEquals(0, first.intValue()); Assert.assertEquals(1, second.intValue()); }
public void testLongValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(3, 2); Assert.assertEquals(0L, first.longValue()); Assert.assertEquals(1L, second.longValue()); }
public void testConstructorDouble() { assertFraction(1, 2, new BigFraction(0.5)); assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0)); assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0)); assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0)); assertFraction(-1, 2, new BigFraction(-0.5)); assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0)); assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0)); assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0)); for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) { try { new BigFraction(v); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException iae) { // expected } } Assert.assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong()); Assert.assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong()); Assert.assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong()); }
public void testAbs() { BigFraction a = new BigFraction(10, 21); BigFraction b = new BigFraction(-10, 21); BigFraction c = new BigFraction(10, -21); assertFraction(10, 21, a.abs()); assertFraction(10, 21, b.abs()); assertFraction(10, 21, c.abs()); }
public void testReciprocal() { BigFraction f = null; f = new BigFraction(50, 75); f = f.reciprocal(); Assert.assertEquals(3, f.getNumeratorAsInt()); Assert.assertEquals(2, f.getDenominatorAsInt()); f = new BigFraction(4, 3); f = f.reciprocal(); Assert.assertEquals(3, f.getNumeratorAsInt()); Assert.assertEquals(4, f.getDenominatorAsInt()); f = new BigFraction(-15, 47); f = f.reciprocal(); Assert.assertEquals(-47, f.getNumeratorAsInt()); Assert.assertEquals(15, f.getDenominatorAsInt()); f = new BigFraction(0, 3); try { f = f.reciprocal(); Assert.fail("expecting ZeroException"); } catch (ZeroException ex) { } // large values f = new BigFraction(Integer.MAX_VALUE, 1); f = f.reciprocal(); Assert.assertEquals(1, f.getNumeratorAsInt()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); }
public void testNegate() { BigFraction f = null; f = new BigFraction(50, 75); f = f.negate(); Assert.assertEquals(-2, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f = new BigFraction(-50, 75); f = f.negate(); Assert.assertEquals(2, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); // large values f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE); f = f.negate(); Assert.assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); }
public void testAdd() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 1, a.add(a)); assertFraction(7, 6, a.add(b)); assertFraction(7, 6, b.add(a)); assertFraction(4, 3, b.add(b)); BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); BigFraction f2 = BigFraction.ONE; BigFraction f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(-1, 13 * 13 * 2 * 2); f2 = new BigFraction(-2, 13 * 17 * 2); f = f1.add(f2); Assert.assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt()); Assert.assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt()); try { f.add((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = new BigFraction(1, 32768 * 3); f2 = new BigFraction(1, 59049); f = f1.add(f2); Assert.assertEquals(52451, f.getNumeratorAsInt()); Assert.assertEquals(1934917632, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, 3); f2 = new BigFraction(1, 3); f = f1.add(f2); Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(BigInteger.ONE); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(BigInteger.ZERO); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(1); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(0); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(1l); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(0l); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); }
public void testDivide() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 1, a.divide(a)); assertFraction(3, 4, a.divide(b)); assertFraction(4, 3, b.divide(a)); assertFraction(1, 1, b.divide(b)); BigFraction f1 = new BigFraction(3, 5); BigFraction f2 = BigFraction.ZERO; try { f1.divide(f2); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } f1 = new BigFraction(0, 5); f2 = new BigFraction(2, 7); BigFraction f = f1.divide(f2); Assert.assertSame(BigFraction.ZERO, f); f1 = new BigFraction(2, 7); f2 = BigFraction.ONE; f = f1.divide(f2); Assert.assertEquals(2, f.getNumeratorAsInt()); Assert.assertEquals(7, f.getDenominatorAsInt()); f1 = new BigFraction(1, Integer.MAX_VALUE); f = f1.divide(f1); Assert.assertEquals(1, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = new BigFraction(1, Integer.MAX_VALUE); f = f1.divide(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); try { f.divide((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE)); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide(Integer.MIN_VALUE); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide((long) Integer.MIN_VALUE); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); }
public void testMultiply() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 4, a.multiply(a)); assertFraction(1, 3, a.multiply(b)); assertFraction(1, 3, b.multiply(a)); assertFraction(4, 9, b.multiply(b)); BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1); BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); BigFraction f = f1.multiply(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f2.multiply(Integer.MAX_VALUE); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f2.multiply((long) Integer.MAX_VALUE); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); try { f.multiply((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } }
public void testSubtract() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); BigFraction f = new BigFraction(1, 1); try { f.subtract((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } // if this fraction is subtracted naively, it will overflow. // check that it doesn't. BigFraction f1 = new BigFraction(1, 32768 * 3); BigFraction f2 = new BigFraction(1, 59049); f = f1.subtract(f2); Assert.assertEquals(-13085, f.getNumeratorAsInt()); Assert.assertEquals(1934917632, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, 3); f2 = new BigFraction(1, 3).negate(); f = f1.subtract(f2); Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE, 1); f2 = BigFraction.ONE; f = f1.subtract(f2); Assert.assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); }
public void testBigDecimalValue() { Assert.assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue()); Assert.assertEquals(new BigDecimal("0.0003"), new BigFraction(3, 10000).bigDecimalValue()); Assert.assertEquals(new BigDecimal("0"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN)); Assert.assertEquals(new BigDecimal("0.333"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN)); }
public void testEqualsAndHashCode() { BigFraction zero = new BigFraction(0, 1); BigFraction nullFraction = null; Assert.assertTrue(zero.equals(zero)); Assert.assertFalse(zero.equals(nullFraction)); Assert.assertFalse(zero.equals(Double.valueOf(0))); BigFraction zero2 = new BigFraction(0, 2); Assert.assertTrue(zero.equals(zero2)); Assert.assertEquals(zero.hashCode(), zero2.hashCode()); BigFraction one = new BigFraction(1, 1); Assert.assertFalse((one.equals(zero) || zero.equals(one))); Assert.assertTrue(one.equals(BigFraction.ONE)); }
public void testGetReducedFraction() { BigFraction threeFourths = new BigFraction(3, 4); Assert.assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8))); Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1))); try { BigFraction.getReducedFraction(1, 0); Assert.fail("expecting ZeroException"); } catch (ZeroException ex) { // expected } Assert.assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1); Assert.assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1); }
public void testPercentage() { Assert.assertEquals(50.0, new BigFraction(1, 2).percentageValue(), 1.0e-15); }
public void testPow() { Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13)); Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l)); Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l))); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0)); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l)); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l))); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13)); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l)); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l))); }
public void testMath340() { BigFraction fractionA = new BigFraction(0.00131); BigFraction fractionB = new BigFraction(.37).reciprocal(); BigFraction errorResult = fractionA.multiply(fractionB); BigFraction correctResult = new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()), fractionA.getDenominator().multiply(fractionB.getDenominator())); Assert.assertEquals(correctResult, errorResult); }
public void testSerial() throws FractionConversionException { BigFraction[] fractions = { new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO, new BigFraction(17), new BigFraction(FastMath.PI, 1000), new BigFraction(-5, 2) }; for (BigFraction fraction : fractions) { Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction)); } }
